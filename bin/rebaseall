#!/usr/bin/ruby

require 'optparse'
require 'set'

class Arguments
	attr_accessor :branch, :skipped
	def initialize(args)
		super()

        self.skipped = Set.new

		opts = OptionParser.new do |opts|
			opts.banner = "Rebase all branches onto another\n"
            opts.banner += "\n"
			opts.banner += "Usage: #$0 [options] <branch>"
			opts.on('-s', '--skip [BRANCH]', 'The branch to skip.') do |branch|
				self.skipped.add branch
			end
			opts.on_tail('-h', '--help', 'display this help and exit.') do
				puts opts
				exit
			end
		end

		opts.parse!(args)
        if args.length == 1 then
            self.branch = args[0]
        end

        if self.branch == nil or self.branch.empty? then
            STDERR.puts "Must supply a branch name."
            STDERR.puts
            STDERR.puts opts
            exit 1
        end
	end
end

$opts = Arguments.new(ARGV)

def getBranchNames
    names = Array.new
    IO.popen('git branch --list') { |f|
        while line=f.gets do
            line.chomp!
            if line =~ /^[\s\*]+(.+)$/ then
                names.push $1
            end
        end
    }
    return names
end

def rebase(branch, newbase)
    puts
    puts branch
    system "git checkout #{branch}"
    if $? != 0 then
        raise "Can't checkout #{branch}"
    end
    system "git rebase #{newbase}"
    if $? != 0 then
        STDERR.puts "Failure rebasing #{branch}. Resolve conflicts and rerun"
        exit 1
    end
end

branches = getBranchNames()
if branches.include?('(no branch)') then
    STDERR.puts "You are currently branchless - fix that first"
    exit 1
end
branches.each {|branch|
    if $opts.skipped.include?(branch) then
        puts
        puts "Skipping #{branch}"
    else
        rebase(branch, $opts.branch)
    end
}
