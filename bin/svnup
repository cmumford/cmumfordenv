#!/usr/bin/perl -w

##
# This is a simple script to front-end a Subversion/GIT update. You 
# can give it zero or more directories to update. Those directories
# can either be under svn control, or have children that are under
# svn control, and they will be updated. Also, the output of 
# Subversion is colorized to more easily pick out conflicts and other
# things of interest.
#

use strict;
use Getopt::Long;

$| = 1;	# Force flushing.

my $numConflicts = 0;
my $verbose = 0;
my $nocolor = 0;

my $result = GetOptions ( "nocolor" => \$nocolor, "verbose" => \$verbose);

my $colorize = not $nocolor;

foreach my $dir (@ARGV) {
	&udateDirOrChildren($dir);
}

if (scalar(@ARGV) == 0) {
	&udateDirOrChildren('.');
}

if ($numConflicts) {
	warn "You have $numConflicts conflicts\n";
}
else {
	print "Updated files, no conflicts\n";
}
exit $numConflicts;

sub udateDirOrChildren()
{
	my $dir = shift;
	
	return if isSvnMetaDir($dir);
	return if isGitMetaDir($dir);
	
	print "Updating dir or children for $dir\n" if $verbose;
	
	if (isDirInSvn($dir)) {
		updateSvnDir($dir);
	}
	elsif (isDirInGit($dir)) {
		updateGitDir($dir);
	}
	else {
		opendir DIR, $dir or die "Can't open directory $dir: $?\n";
		my @files = readdir DIR;
		closedir DIR;
		
		foreach my $file (sort { lc $a cmp lc $b } @files) {
			next if $file eq '.';
			next if $file eq '..';
			
			my $fullpath = "$dir/$file";
			
			print " fullpath $fullpath\n" if $verbose;
			
			if ( -d $fullpath ) {
				if (isDirInSvn($fullpath)) {
					updateSvnDir($fullpath);
				}
				elsif (isDirInGit($fullpath)) {
					updateGitDir($fullpath);
				}
				else {
					print "$fullpath is not under revision control\n" if not shouldIgnoreDir($fullpath);
				}
			}
		}
	}
}

sub updateGitDir()
{
	my $dir = shift;
	
	print "Updating $dir via Git\n";

	print `cd $dir && git pull`;
}

sub updateSvnDir()
{
	my $dir = shift;
	
	print "Updating $dir via Svn\n";

	foreach ( `svn up $dir` ) {
		chomp;
		if ($colorize) {
			if ( m/^M/ ) {		# Modified
				print "\e[0;34m$_\e[0m\n";	# blue/black
			}
			elsif ( m/^A/ ) {		# Added
				print "\e[0;36m$_\e[0m\n";	# cyan/black
			}
			elsif ( m/^D/ ) {		# Deleted
				print "\e[0;33m$_\e[0m\n";	# brown/black
			}
			elsif ( m/^C/ ) {		# Conflicted
				print "\e[0;31m$_\e[0m\n";	# red/black
				$numConflicts++;
			}
			elsif ( m/^!/ ) {		# item is missing (removed by non-svn command) or incomplete
				print "\e[0;31m$_\e[0m\n";	# red/black
			}
			else {	# Everything else
				print "$_\n";
			}
		}
		else {
			print "$_\n";
		}
	}
}

sub isDirInSvn()
{
	my $dir = shift;
	
	return -d "$dir/.svn";
}

sub isDirInGit()
{
	my $dir = shift;
	
	return -d "$dir/.git";
}

sub shouldIgnoreDir()
{
	my $dir = shift;
	
	return 1 if isSvnMetaDir($dir);
	return 1 if isGitMetaDir($dir);
	return 1 if $dir =~ m/\.metadata$/;
	
	return 0;
}

sub isSvnMetaDir()
{
	my $dir = shift;
	
	return 1 if $dir =~ m/\.svn/;
}

sub isGitMetaDir()
{
	my $dir = shift;
	
	return 1 if $dir =~ m/\.git/;
}
